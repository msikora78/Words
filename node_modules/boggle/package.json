{
  "name": "boggle",
  "version": "0.0.3",
  "description": "Boggle grid solver",
  "main": "index.js",
  "preferGlobal": "true",
  "bin": {
    "boggle": "./index.js"
  },
  "scripts": {
    "test": "gt src/test/*.js --output",
    "complexity": "jsc index.js src/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://bitbucket.org/bahmutov/boggle.git"
  },
  "keywords": [
    "boggle",
    "solver",
    "words"
  ],
  "author": {
    "name": "Gleb Bahmutov",
    "email": "gleb.bahmutov@gmail.com"
  },
  "license": "MIT",
  "dependencies": {
    "check-types": "~0.6.4",
    "matrix-paths": "0.0.2",
    "prefix-dictionary": "0.0.0"
  },
  "devDependencies": {
    "gt": "~0.8.8",
    "jsc": "~0.3.5"
  },
  "readme": "# Boggle solver\r\n\r\nSmall simple nodejs based Boggle grid solver\r\n\r\n## Install and run\r\n\r\nAfter installing nodejs, run:\r\n\r\n    npm install -g boggle\r\n    // ignore any warnings\r\n    boggle \"ABCD EFGH IJKL MNOP\"\r\n\r\nThe spaces between letters are optional, it could be single\r\nstring with 16 characters. In this case, you don't need quotes:\r\n\r\n    boggle ABCDEFGHIJKLMNOP\r\n\r\nCase does not matter, characters will be converted to lowercase.\r\n\r\n## Main logic\r\n\r\nThe algorithm iterates over the 2D grid, trying to walk\r\ndepth first, including diagonally, but not\r\nvisiting same cell more than once. At each step, the accumulated\r\nstring is checked against the dictionary. Walking stops and\r\nthe algorithm backtracks to previous depth level if the string\r\nis no longer a valid word or valid word prefix.\r\n\r\n    // src/boggle.js\r\n    var uniqueWords = {};\r\n    paths(lowerCased, {\r\n        stepWhile: function (str, x, y, grid) {\r\n            if (dictionary.isWord(str)) {\r\n                // found whole word, maybe there is more!\r\n                uniqueWords[str] = true;\r\n                return true;\r\n            }\r\n            if (dictionary.isWordPrefix(str)) {\r\n                // not a word, but possible\r\n                return true;\r\n            }\r\n        }\r\n    });\r\n\r\n    var words = Object.keys(uniqueWords);\r\n    words = utils.validWords(words);\r\n\r\n## Dependencies\r\n\r\nTo discover paths in the letter grid, I use [matrix-paths](https://bitbucket.org/bahmutov/matrix-paths). While walking through the matrix, I use boggle [prefix-dictionary](https://bitbucket.org/bahmutov/prefix-dictionary) that uses a [**trie**](http://en.wikipedia.org/wiki/Trie) data structure. Trie is a binary search tree that stores words in addition to children links, making word or prefix matching very quick.\r\n\r\n## Testing and code complexity\r\n\r\nTo unit and function test the module, execute command\r\n\r\n    npm test\r\n\r\nThis might require installing [gt](https://npmjs.org/package/gt) testing tool globally\r\n\r\n    npm install -g gt\r\n\r\nTo see code complexity (it is very low), run command\r\n\r\n    npm run-script complexity\r\n\r\nThis might require installing [jsc](https://npmjs.org/package/jsc) tool globally\r\n\r\n    npm install -g jsc\r\n\r\n## Todo\r\n\r\n* Use jshint to see possible bugs\r\n* check dictionary initialization (is it a good idea to initialize using a sorted words array)\r\n* hook into trie implementation to store previous prefix query, because we keep asking for same prefix path \"h - he - hel - hell - hello\".",
  "readmeFilename": "README.md",
  "_id": "boggle@0.0.3",
  "_from": "boggle@*"
}
